<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>耶穌基督的福音 - 尋找生命的橋樑</title>
    <!-- 引入 Tailwind CSS 進行 UI 排版 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入 Three.js 核心庫 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- 引入 OrbitControls 讓使用者可以旋轉視角 -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- 引入 GSAP 動畫庫，處理順滑的過渡效果 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'PingFang TC', 'Heiti TC', 'Microsoft JhengHei', sans-serif; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        
        /* 允許 UI 元素被點擊 */
        .pointer-events-auto { pointer-events: auto; }
        
        /* 漸層背景遮罩，讓文字在 3D 背景上更容易閱讀 */
        .text-panel-bg { background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.6) 70%, transparent 100%); }
        .top-panel-bg { background: linear-gradient(to bottom, rgba(0,0,0,0.7) 0%, transparent 100%); }
        
        /* 動畫過渡類別 */
        .transition-all { transition: all 0.4s ease; }
        
        /* 自定義滾動條 (如果文字太長) */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: rgba(255,255,255,0.1); }
        ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.3); border-radius: 3px; }
    </style>
</head>
<body class="text-white select-none">

    <!-- 3D 畫布容器 -->
    <div id="canvas-container"></div>

    <!-- UI 控制層 -->
    <div id="ui-layer">
        
        <!-- 頂部列：標題與設定按鈕 -->
        <div class="top-panel-bg w-full p-4 flex justify-between items-start pointer-events-auto">
            <div>
                <h1 class="text-2xl md:text-3xl font-bold tracking-wider text-yellow-300 drop-shadow-md">耶穌基督的福音</h1>
                <p class="text-sm md:text-base text-gray-200 mt-1 opacity-80">尋找生命的橋樑</p>
            </div>
            <div class="flex flex-col gap-2">
                <button id="btn-text-size" class="bg-white/20 hover:bg-white/30 backdrop-blur border border-white/30 rounded-full px-4 py-2 text-sm transition-all flex items-center gap-2 cursor-pointer">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 4h13M3 8h9m-9 4h6m4 0l4-8m0 0l4 8m-4-8v12"></path></svg>
                    <span>字體大小</span>
                </button>
                <button id="btn-reset" class="bg-red-500/80 hover:bg-red-500 backdrop-blur border border-red-400/50 rounded-full px-4 py-2 text-sm transition-all flex items-center gap-2 cursor-pointer">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path></svg>
                    <span>重新開始</span>
                </button>
            </div>
        </div>

        <!-- 底部列：故事內容與導航按鈕 -->
        <div class="text-panel-bg w-full pt-12 pb-6 px-4 md:px-12 pointer-events-auto">
            <div class="max-w-4xl mx-auto">
                
                <!-- 階段指示器 (圓點) -->
                <div class="flex justify-center gap-2 md:gap-4 mb-4" id="stage-indicators">
                    <!-- JS 會動態生成 5 個圓點 -->
                </div>

                <!-- 故事內容區 -->
                <div class="min-h-[120px] max-h-[35vh] overflow-y-auto mb-4 pr-2">
                    <h2 id="story-title" class="text-xl md:text-2xl font-bold text-yellow-400 mb-3 transition-all">載入中...</h2>
                    <p id="story-content" class="text-base md:text-lg leading-relaxed text-gray-100 transition-all">
                        請稍候...
                    </p>
                </div>

                <!-- 控制按鈕區 -->
                <div class="flex justify-between items-center border-t border-white/20 pt-4">
                    <button id="btn-prev" class="px-6 py-2 rounded-full bg-white/10 hover:bg-white/20 transition-all disabled:opacity-30 disabled:cursor-not-allowed cursor-pointer">
                        上一頁
                    </button>
                    <span id="stage-counter" class="text-gray-400 text-sm font-mono tracking-widest">1 / 5</span>
                    <button id="btn-next" class="px-6 py-2 rounded-full bg-yellow-500 hover:bg-yellow-400 text-black font-bold transition-all disabled:opacity-30 disabled:cursor-not-allowed shadow-[0_0_15px_rgba(234,179,8,0.4)] cursor-pointer">
                        下一頁
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ==========================================
        // 1. 故事文本設定
        // ==========================================
        const storyData = [
            {
                title: "創世記 1:1<br>起初，神創造天地。",
                content: "起初，神創造了完美的世界。那時，人與神親密無間，充滿喜樂平安。<br>人生活在天父的光明與愛中，沒有任何隔閡。"
            },
            {
                title: "羅馬書 3:23<br>因為世人都犯了罪，虧缺了神的榮耀。",
                content: "然而，人犯罪背叛了神。人因為有罪的緣故，與聖潔的神分隔。<br>失去神同在的人類世界變得充滿了邪惡、憤怒、紛爭、憂慮與悲哀⋯"
            },
            {
                title: "羅馬書 6:23<br>因為罪的工價乃是死⋯",
                content: "人類與聖潔的神被罪惡與死亡的深淵隔絕；<br>即使用盡各種方法（例如善行、知識、智慧、道德）想跨越這道鴻溝回到美善的天父那裡，卻總是徒勞無功。<br>世界充滿了孤單、傷痛、絕望、無助⋯"
            },
            {
                title: "約翰福音 3:16<br>神愛世人，甚至將他的獨生子賜給他們，叫一切信他的，不至滅亡，反得永生。",
                content: "但天父依然愛我們！神差遣祂的獨生子耶穌基督來到世上拯救我們。<br>無罪的耶穌為了救贖我們，親自承擔了我們的罪，被釘死在十字架上，並在第三天復活了！<br>救主耶穌成為了世人重新回到天父的唯一道路！"
            },
            {
                title: "約翰福音 10:10b<br>耶穌：「我來了，是要叫人得生命，並且得的更豐盛。」",
                content: "耶穌基督來到世上的目的，就是要讓人得著真正的生命！<br>只要您願意相信並接受耶穌作您的救主，就能藉著這唯一的道路，跨越罪惡與死亡的深淵，重新回到天父那裡❤️"
            }
        ];

        let currentStage = 0;
        let isLargeText = false;

        // ==========================================
        // 2. Three.js 場景基礎設定
        // ==========================================
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // 初始天空藍色
        scene.background = new THREE.Color(0x87CEEB); 
        scene.fog = new THREE.Fog(0x87CEEB, 20, 60);

        // 攝影機設定
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 12, 35);

        // 渲染器設定
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        container.appendChild(renderer.domElement);

        // 視角控制器 (OrbitControls)
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.05; // 限制不能看到地底下
        controls.minDistance = 20;
        controls.maxDistance = 50;
        controls.enablePan = false;

        // ==========================================
        // 3. 燈光與材質顏色定義
        // ==========================================
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        // 調整陰影範圍
        dirLight.shadow.camera.left = -20;
        dirLight.shadow.camera.right = 20;
        dirLight.shadow.camera.top = 20;
        dirLight.shadow.camera.bottom = -20;
        scene.add(dirLight);

        const colors = {
            skyBright: 0x87CEEB,
            skyDark: 0x2C3E50,
            skyGolden: 0xFFDE73,
            grassBright: 0x32CD32, // 翠綠色
            grassDark: 0x556B2F,
            grassDead: 0x8B7355,
            riverBlue: 0x1E90FF,
            riverDark: 0x1C2833,
            leafGreen: 0x228B22,
            leafDead: 0x8B4513,
            wood: 0x8B4513
        };

        const matLeftLand = new THREE.MeshStandardMaterial({ color: colors.grassBright });
        const matRightLand = new THREE.MeshStandardMaterial({ color: colors.grassBright });
        const matRiver = new THREE.MeshStandardMaterial({ color: colors.riverBlue, transparent: true, opacity: 0.8 });
        
        // ==========================================
        // 4. 場景核心物件建立
        // ==========================================
        
        // 4.1 大地 (左：人的世界 / 右：神的世界)
        const leftLandGroup = new THREE.Group();
        const leftLandGeo = new THREE.BoxGeometry(20, 4, 20);
        const leftLand = new THREE.Mesh(leftLandGeo, matLeftLand);
        leftLand.receiveShadow = true;
        leftLand.position.y = -2;
        leftLandGroup.add(leftLand);
        leftLandGroup.position.x = -10;
        scene.add(leftLandGroup);

        const rightLandGroup = new THREE.Group();
        const rightLandGeo = new THREE.BoxGeometry(20, 4, 20);
        const rightLand = new THREE.Mesh(rightLandGeo, matRightLand);
        rightLand.receiveShadow = true;
        rightLand.position.y = -2;
        rightLandGroup.add(rightLand);
        rightLandGroup.position.x = 10;
        scene.add(rightLandGroup);

        // 4.2 河流/深淵 (位於底層)
        const riverGeo = new THREE.PlaneGeometry(60, 60);
        const river = new THREE.Mesh(riverGeo, matRiver);
        river.rotation.x = -Math.PI / 2;
        river.position.y = -3.5;
        river.receiveShadow = true;
        scene.add(river);

        // ==========================================
        // 5. 模型輔助建造函數
        // ==========================================
        
        // 建立普通樹木
        function createTree(isDead = false) {
            const group = new THREE.Group();
            const trunkGeo = new THREE.CylinderGeometry(0.2, 0.3, 1, 8);
            const trunkMat = new THREE.MeshStandardMaterial({ color: colors.wood });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 0.5;
            trunk.castShadow = true;
            group.add(trunk);

            const leavesGeo = new THREE.ConeGeometry(1, 2, 8);
            const leavesMat = new THREE.MeshStandardMaterial({ color: isDead ? colors.leafDead : colors.leafGreen });
            const leaves = new THREE.Mesh(leavesGeo, leavesMat);
            leaves.position.y = 2;
            leaves.castShadow = true;
            group.add(leaves);

            return group;
        }

        // 建立結滿紅色果實的樹 (用於神的世界)
        function createFruitTree() {
            const group = createTree(false);
            // 加入 6 顆隨機位置的紅果實
            for(let i=0; i<6; i++) {
                const fruit = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15, 8, 8),
                    new THREE.MeshStandardMaterial({color: 0xFF3333})
                );
                const angle = Math.random() * Math.PI * 2;
                const r = 0.4 + Math.random() * 0.4;
                const y = 1.2 + Math.random() * 1.2;
                fruit.position.set(Math.cos(angle)*r, y, Math.sin(angle)*r);
                fruit.castShadow = true;
                group.add(fruit);
            }
            return group;
        }

        // 建立花朵
        function createFlower() {
            const group = new THREE.Group();
            const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.3, 8), new THREE.MeshStandardMaterial({color: 0x228B22}));
            stem.position.y = 0.15;
            stem.castShadow = true;
            
            const flowerColors = [0xFF1493, 0xFF4500, 0x9370DB, 0xFFFF00, 0xFFFFFF];
            const color = flowerColors[Math.floor(Math.random() * flowerColors.length)];
            const petal = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 8), new THREE.MeshStandardMaterial({color: color}));
            petal.position.y = 0.3;
            petal.castShadow = true;
            
            group.add(stem, petal);
            return group;
        }

        // 建立汽車 (第二階段人的世界)
        function createCar() {
            const group = new THREE.Group();
            const carColors = [0xcc0000, 0x0000cc, 0x222222, 0xdddddd];
            const mat = new THREE.MeshStandardMaterial({color: carColors[Math.floor(Math.random() * carColors.length)]});
            
            // 車身
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.5, 0.6), mat);
            body.position.y = 0.4;
            body.castShadow = true;
            
            // 車頂
            const top = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.3, 0.5), mat);
            top.position.set(0, 0.8, 0);
            top.castShadow = true;
            
            group.add(body, top);
            
            // 四個輪胎
            const tireGeo = new THREE.CylinderGeometry(0.15, 0.15, 0.1, 16);
            const tireMat = new THREE.MeshStandardMaterial({color: 0x111111});
            const poses = [[-0.35, 0.15, 0.3], [0.35, 0.15, 0.3], [-0.35, 0.15, -0.3], [0.35, 0.15, -0.3]];
            poses.forEach(p => {
                const tire = new THREE.Mesh(tireGeo, tireMat);
                tire.rotation.x = Math.PI/2;
                tire.position.set(...p);
                tire.castShadow = true;
                group.add(tire);
            });
            return group;
        }

        // 建立建築物 (第二階段人的世界)
        function createBuilding() {
            const height = 1 + Math.random() * 3;
            const geo = new THREE.BoxGeometry(1, height, 1);
            const mat = new THREE.MeshStandardMaterial({ color: 0x555555 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.y = height / 2;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            return mesh;
        }

        // 建立人物 (可設定顏色與是否發光)
        function createPerson(color, isGlowing = false) {
            const group = new THREE.Group();
            
            // 身體
            const bodyGeo = new THREE.CylinderGeometry(0.3, 0.4, 1.2, 16);
            const mat = new THREE.MeshStandardMaterial({ 
                color: color, 
                emissive: isGlowing ? color : 0x000000, 
                emissiveIntensity: isGlowing ? 0.8 : 0 
            });
            const body = new THREE.Mesh(bodyGeo, mat);
            body.position.y = 0.6;
            body.castShadow = true;
            group.add(body);
            
            // 頭部
            const headGeo = new THREE.SphereGeometry(0.35, 16, 16);
            const head = new THREE.Mesh(headGeo, mat);
            head.position.y = 1.4;
            head.castShadow = true;
            group.add(head);

            // 發光體設定
            if (isGlowing) {
                // 點光源照亮周圍
                const light = new THREE.PointLight(color, 1, 10);
                light.position.y = 1;
                group.add(light);
                
                // 半透明光暈
                const haloGeo = new THREE.SphereGeometry(0.8, 16, 16);
                const haloMat = new THREE.MeshBasicMaterial({ 
                    color: color, 
                    transparent: true, 
                    opacity: 0.3, 
                    blending: THREE.AdditiveBlending 
                });
                const halo = new THREE.Mesh(haloGeo, haloMat);
                halo.position.y = 1;
                group.add(halo);
            }
            return group;
        }

        // 建立十字架橋樑
        function createCross() {
            const group = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: colors.wood });
            
            // 直條 (長度10跨越裂縫，中心點偏移方便旋轉倒下)
            const vGeo = new THREE.BoxGeometry(0.6, 10, 0.6);
            vGeo.translate(0, 5, 0); 
            const vMesh = new THREE.Mesh(vGeo, mat);
            vMesh.castShadow = true;
            group.add(vMesh);

            // 橫條 (放置在高度 7 的位置，這也是之後耶穌掛上的位置)
            const hGeo = new THREE.BoxGeometry(4, 0.6, 0.6);
            const hMesh = new THREE.Mesh(hGeo, mat);
            hMesh.position.y = 7; 
            hMesh.castShadow = true;
            group.add(hMesh);

            return group;
        }

        // ==========================================
        // 6. 放置場景物件
        // ==========================================
        
        // 6.1 主要角色
        const man = createPerson(0x3498DB); // 藍色代表人
        scene.add(man);

        const god = createPerson(0xFFD700, true); // 金色發光代表神
        god.scale.set(1.6, 1.6, 1.6); // 上帝尺寸較大
        scene.add(god);

        const jesus = createPerson(0xFFFFFF, true); // 白色發光代表耶穌
        jesus.scale.set(1.6, 1.6, 1.6); // 耶穌與上帝一樣大
        scene.add(jesus);
        jesus.visible = false; // 初始隱藏

        const cross = createCross();
        scene.add(cross);
        cross.visible = false; // 初始隱藏

        // 6.2 左邊人的世界裝飾 (樹、花、隱藏的城市與惡人)
        const leftTrees = [];
        const leftBuildings = [];
        const leftFlowers = [];
        const leftCars = [];
        const evilPeople = [];
        
        // 左邊的樹
        for(let i=0; i<12; i++) {
            const tree = createTree();
            tree.position.set(-9 + Math.random()*16, 0, -8 + Math.random()*16);
            leftLandGroup.add(tree);
            leftTrees.push(tree);
        }

        // 左邊的花草
        for(let i=0; i<25; i++) {
            const flower = createFlower();
            flower.position.set(-9 + Math.random()*17, 0, -9 + Math.random()*18);
            leftLandGroup.add(flower);
            leftFlowers.push(flower);
        }

        // 左邊的城市、車子、罪惡小人 (初始都在地底下 y = -5)
        for(let i=0; i<15; i++) {
            const bldg = createBuilding();
            bldg.position.set(-9 + Math.random()*15, -5, -8 + Math.random()*16);
            leftLandGroup.add(bldg);
            leftBuildings.push(bldg);
        }
        for(let i=0; i<6; i++) {
            const car = createCar();
            car.position.set(-8 + Math.random()*12, -5, -7 + Math.random()*14);
            car.rotation.y = Math.random() * Math.PI;
            leftLandGroup.add(car);
            leftCars.push(car);
        }
        for(let i=0; i<10; i++) {
            const p = createPerson(0x222222); // 黑色代表罪惡
            p.position.set(-8 + Math.random()*14, -5, -8 + Math.random()*16);
            p.rotation.y = Math.random() * Math.PI * 2;
            leftLandGroup.add(p);
            evilPeople.push(p);
        }

        // 6.3 右邊神的世界裝飾 (果樹、花、生命樹)
        const rightTrees = [];
        const rightFlowers = [];
        
        // 右邊的翠綠果樹
        for(let i=0; i<18; i++) {
            const tree = createFruitTree();
            tree.position.set(-2 + Math.random()*12, 0, -10 + Math.random()*18);
            rightLandGroup.add(tree);
            rightTrees.push(tree);
        }

        // 特別放置一棵較大的果樹作為右側花園的生命樹
        const bigFruitTree = createFruitTree();
        bigFruitTree.scale.set(1.5, 1.5, 1.5);
        bigFruitTree.position.set(4, 0, -4);
        rightLandGroup.add(bigFruitTree);
        rightTrees.push(bigFruitTree);

        // 右邊的花草
        for(let i=0; i<30; i++) {
            const flower = createFlower();
            flower.position.set(-4 + Math.random()*12, 0, -9 + Math.random()*18);
            rightLandGroup.add(flower);
            rightFlowers.push(flower);
        }

        // 6.4 天空裝飾 (彩虹與雲朵)
        const rainbowMaterials = [];
        const rainbowGroup = new THREE.Group();
        const rainbowColors = [0xFF0000, 0xFF7F00, 0xFFFF00, 0x00FF00, 0x0000FF, 0x4B0082, 0x8B00FF];
        rainbowColors.forEach((color, i) => {
            const geo = new THREE.TorusGeometry(18 - i*0.4, 0.4, 16, 100, Math.PI);
            // 彩虹透明度 0.9 
            const mat = new THREE.MeshBasicMaterial({color: color, transparent: true, opacity: 0.9, side: THREE.DoubleSide});
            const ring = new THREE.Mesh(geo, mat);
            rainbowGroup.add(ring);
            rainbowMaterials.push(mat);
        });
        rainbowGroup.position.set(0, -2, -25); // 放在背景遠處
        scene.add(rainbowGroup);

        const cloudsGroup = new THREE.Group();
        const cloudMaterials = [];
        // 建立 10 朵白雲
        for(let i=0; i<10; i++) {
            const cloud = new THREE.Group();
            const geo = new THREE.SphereGeometry(1.5, 16, 16);
            const mat = new THREE.MeshStandardMaterial({color: 0xFFFFFF, transparent: true, opacity: 0.8});
            cloudMaterials.push(mat);
            // 每朵雲由 4 個球體隨機組合而成
            for(let j=0; j<4; j++) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set((Math.random()-0.5)*3, (Math.random()-0.5)*1.5, (Math.random()-0.5)*2);
                mesh.scale.setScalar(0.6 + Math.random()*0.8);
                cloud.add(mesh);
            }
            cloud.position.set(-30 + Math.random()*60, 12 + Math.random()*10, -10 - Math.random()*20);
            cloudsGroup.add(cloud);
        }
        scene.add(cloudsGroup);

        // 6.5 雨水粒子系統 (用於二、三階段)
        const rainGeo = new THREE.BufferGeometry();
        const rainCount = 1500;
        const rainPositions = new Float32Array(rainCount * 3);
        for(let i=0; i<rainCount*3; i+=3) {
            rainPositions[i] = (Math.random() - 0.5) * 40; 
            rainPositions[i+1] = Math.random() * 20;       
            rainPositions[i+2] = (Math.random() - 0.5) * 30; 
        }
        rainGeo.setAttribute('position', new THREE.BufferAttribute(rainPositions, 3));
        const rainMat = new THREE.PointsMaterial({
            color: 0xaaaaaa,
            size: 0.1,
            transparent: true,
            opacity: 0.6
        });
        const rainSystem = new THREE.Points(rainGeo, rainMat);
        scene.add(rainSystem);
        rainSystem.visible = false;


        // ==========================================
        // 7. 動畫與狀態邏輯
        // ==========================================

        // 將場景重置為第一階段的初始狀態
        function resetPositions() {
            // 清除所有正在執行的 GSAP 動畫
            gsap.killTweensOf("*");
            
            // 土地位置 (初始相連)
            leftLandGroup.position.x = -10; 
            
            // 角色位置
            man.position.set(-1, 0, 2); 
            man.rotation.set(0, Math.PI/2, 0); 
            // 上帝遠離深淵 (x=6)
            god.position.set(6, 0, 2); 
            
            // 耶穌與十字架隱藏並重置位置
            jesus.visible = false;
            cross.visible = false;
            cross.rotation.z = 0;
            cross.position.set(-2.5, 0, 2);
            jesus.position.z = 3.0; // Z 深度剛好貼齊十字架前方
            
            // 恢復耶穌的發光狀態 (避免第四階段重置後沒光)
            jesus.children[0].material.emissiveIntensity = 0.8; 
            if(jesus.children[2]) jesus.children[2].intensity = 1;
            if(jesus.children[3]) jesus.children[3].material.opacity = 0.3;

            rainSystem.visible = false;

            // 環境顏色重置
            scene.background.setHex(colors.skyBright);
            scene.fog.color.setHex(colors.skyBright);
            matLeftLand.color.setHex(colors.grassBright);
            matRiver.color.setHex(colors.riverBlue);
            ambientLight.intensity = 0.6;
            dirLight.intensity = 0.8;

            // 彩虹與雲朵顏色重置
            rainbowMaterials.forEach(m => m.opacity = 0.9);
            cloudMaterials.forEach(m => m.color.setHex(0xFFFFFF));

            // 左邊裝飾物重置 (樹變綠、花升起、建築惡人沉入地底)
            leftTrees.forEach(t => {
                t.position.y = 0;
                t.children[1].material.color.setHex(colors.leafGreen);
                t.scale.set(1, 1, 1);
            });
            leftFlowers.forEach(f => f.position.y = 0);
            leftBuildings.forEach(b => b.position.y = -5);
            leftCars.forEach(c => c.position.y = -5);
            evilPeople.forEach(p => p.position.y = -5);
        }

        // 播放各階段動畫
        function playStageAnimation(stageIndex) {
            gsap.killTweensOf("*");
            const tl = gsap.timeline();

            switch(stageIndex) {
                case 0: 
                    // 階段 1：神創造
                    resetPositions();
                    gsap.to(camera.position, {x: 0, y: 12, z: 35, duration: 2, ease: "power2.inOut"});
                    break;

                case 1: 
                    // 階段 2：人犯罪
                    // 左側大地往左移動裂開深淵
                    tl.to(leftLandGroup.position, { x: -16, duration: 2, ease: "power2.inOut" }, 0);
                    tl.to(man.position, { x: -7, duration: 2, ease: "power2.inOut" }, 0);
                    tl.to(camera.position, {x: -3, y: 12, z: 35, duration: 2, ease: "power2.inOut"}, 0); // 鏡頭跟隨
                    
                    // 環境變暗
                    tl.to(scene.background, { r: new THREE.Color(colors.skyDark).r, g: new THREE.Color(colors.skyDark).g, b: new THREE.Color(colors.skyDark).b, duration: 2 }, 0);
                    tl.to(scene.fog.color, { r: new THREE.Color(colors.skyDark).r, g: new THREE.Color(colors.skyDark).g, b: new THREE.Color(colors.skyDark).b, duration: 2 }, 0);
                    tl.to(matLeftLand.color, { r: new THREE.Color(colors.grassDead).r, g: new THREE.Color(colors.grassDead).g, b: new THREE.Color(colors.grassDead).b, duration: 2 }, 0);
                    tl.to(matRiver.color, { r: new THREE.Color(colors.riverDark).r, g: new THREE.Color(colors.riverDark).g, b: new THREE.Color(colors.riverDark).b, duration: 2 }, 0);
                    
                    tl.to(ambientLight, { intensity: 0.2, duration: 2 }, 0);
                    tl.to(dirLight, { intensity: 0.2, duration: 2 }, 0);

                    // 彩虹消失，雲變烏雲
                    rainbowMaterials.forEach(m => tl.to(m, { opacity: 0, duration: 2 }, 0));
                    cloudMaterials.forEach(m => tl.to(m.color, { r: 0.3, g: 0.3, b: 0.3, duration: 2 }, 0));

                    // 左側自然枯萎
                    leftTrees.forEach(t => {
                        tl.to(t.children[1].material.color, { r: new THREE.Color(colors.leafDead).r, g: new THREE.Color(colors.leafDead).g, b: new THREE.Color(colors.leafDead).b, duration: 2 }, 0);
                        tl.to(t.scale, { x: 0.8, y: 0.8, z: 0.8, duration: 2 }, 0);
                    });
                    leftFlowers.forEach(f => tl.to(f.position, { y: -2, duration: 2 }, 0));

                    // 左側罪惡與混亂(城市/車/惡人)從地底升起
                    leftBuildings.forEach(b => tl.to(b.position, { y: b.geometry.parameters.height / 2, duration: 2, ease: "back.out(1.2)" }, 0.5 + Math.random()));
                    leftCars.forEach(c => tl.to(c.position, { y: 0, duration: 2, ease: "back.out(1.2)" }, 0.5 + Math.random()));
                    evilPeople.forEach(p => tl.to(p.position, { y: 0, duration: 2, ease: "back.out(1.2)" }, 0.5 + Math.random()));

                    // 開始下雨
                    setTimeout(() => { rainSystem.visible = true; }, 1000);
                    break;

                case 2: 
                    // 階段 3：神人隔
                    // 確保狀態延續 (防呆跳轉)
                    if (leftLandGroup.position.x > -15) {
                        leftLandGroup.position.x = -16;
                        man.position.x = -7;
                        scene.background.setHex(colors.skyDark);
                        rainSystem.visible = true;
                    }
                    // 第一次跳躍嘗試
                    tl.to(man.position, { x: -4, y: 2, duration: 0.5, ease: "power1.out" }) 
                      .to(man.position, { x: -6.5, y: -0.5, duration: 0.4, ease: "power1.in" }) 
                      .to(man.position, { y: 0, duration: 0.2, ease: "bounce.out" }) 
                      .to(man.position, { x: -7.5, duration: 0.5 }) 
                    // 第二次更用力的跳躍嘗試
                      .to(man.position, { x: -3.5, y: 2.2, duration: 0.5, ease: "power1.out" }) 
                      .to(man.position, { x: -6.5, y: -0.5, duration: 0.4, ease: "power1.in" }) 
                      .to(man.position, { y: 0, duration: 0.2, ease: "bounce.out" }) 
                      .to(man.position, { x: -7.5, duration: 1 }) 
                    // 第三次更用力的跳躍嘗試
                      .to(man.position, { x: -3.5, y: 2.2, duration: 0.5, ease: "power1.out" }) 
                      .to(man.position, { x: -6.5, y: -0.5, duration: 0.4, ease: "power1.in" }) 
                      .to(man.position, { y: 0, duration: 0.2, ease: "bounce.out" }) 
                      .to(man.position, { x: -7.5, duration: 1 }) 
                      // 視角拉近，凸顯孤單感
                      .to(camera.position, {x: -3, y: 8, z: 25, duration: 3, ease: "power2.inOut"}, 0);
                    break;

                case 3: 
                    // 階段 4：耶穌臨
                    if (leftLandGroup.position.x > -15) leftLandGroup.position.x = -16;
                    
                    tl.to(camera.position, {x: -3, y: 10, z: 30, duration: 1.5, ease: "power2.inOut"}, 0);

                    // 耶穌從天降臨
                    jesus.visible = true;
                    jesus.position.set(-3, 15, 3.0); 
                    
                    // 雨停，天空微亮
                    rainSystem.visible = false;
                    tl.to(scene.background, { r: 0.3, g: 0.4, b: 0.5, duration: 2 }, 0);
                    tl.to(ambientLight, { intensity: 0.4, duration: 2 }, 0);

                    tl.to(jesus.position, { y: 0, duration: 2, ease: "power2.out" })
                      .to(man.position, { x: -6.5, duration: 1 }, "-=1"); // 人物靠近看

                    // 十字架從地底升起
                    cross.visible = true;
                    cross.position.set(-3, -10, 2); 
                    cross.rotation.z = 0;
                    
                    tl.to(cross.position, { y: 0, duration: 1.5, ease: "back.out(1.2)" });
                    
                    // 耶穌上十字架 (y=5.5 完美緊貼交叉點)
                    tl.to(jesus.position, { y: 5.5, duration: 1 })
                      .to(jesus.children[0].material, { emissiveIntensity: 0.1, duration: 1 }, "-=1") // 身體光芒變暗象徵受苦
                      .to(jesus.children[2], { intensity: 0.2, duration: 1 }, "-=1") 
                      .to(jesus.children[3].material, { opacity: 0.05, duration: 1 }, "-=1") 
                      
                    // ★ 釘十字架畫面停留 2 秒，讓人深刻感受
                    tl.to(jesus.children[0].material, { emissiveIntensity: 0, duration: 0.5 }, "+=2") 
                      .call(() => { jesus.visible = false; }) // 耶穌死亡隱藏
                      // 十字架倒下成為橋樑
                      .to(cross.position, { x: -6, duration: 0.5 })
                      .to(cross.rotation, { z: -Math.PI / 2, duration: 1.5, ease: "bounce.out" });

                    // 耶穌復活 (在右側神的世界出現)
                    tl.call(() => {
                        jesus.visible = true;
                        jesus.position.set(2, 5, 2); 
                        jesus.children[0].material.emissiveIntensity = 0.8;
                        jesus.children[2].intensity = 1;
                        jesus.children[3].material.opacity = 0.3;
                    })
                    .to(jesus.position, { y: 0, duration: 1.5, ease: "power2.out" })
                    .to(jesus.position, { x: 4, duration: 1 });
                    break;

                case 4: 
                    // 階段 5：神復和
                    // 確保橋樑與耶穌位置正確
                    cross.visible = true;
                    cross.position.set(-6, 0, 2);
                    cross.rotation.z = -Math.PI / 2;
                    jesus.visible = true;
                    jesus.position.set(4, 0, 2);

                    // 整個世界變成明亮溫暖的金色晨曦
                    tl.to(scene.background, { r: new THREE.Color(colors.skyGolden).r, g: new THREE.Color(colors.skyGolden).g, b: new THREE.Color(colors.skyGolden).b, duration: 2 }, 0);
                    tl.to(scene.fog.color, { r: new THREE.Color(colors.skyGolden).r, g: new THREE.Color(colors.skyGolden).g, b: new THREE.Color(colors.skyGolden).b, duration: 2 }, 0);
                    tl.to(matRiver.color, { r: new THREE.Color(colors.riverBlue).r, g: new THREE.Color(colors.riverBlue).g, b: new THREE.Color(colors.riverBlue).b, duration: 2 }, 0);
                    tl.to(ambientLight, { intensity: 0.7, duration: 2 }, 0);
                    tl.to(dirLight, { intensity: 1, duration: 2 }, 0);
                    
                    cloudMaterials.forEach(m => tl.to(m.color, { r: 1, g: 0.9, b: 0.8, duration: 2 }, 0));

                    // 人物過橋回到神的世界
                    tl.to(man.position, { x: -6, duration: 0.5 }) 
                      .to(man.position, { x: -1, y: 0.6, duration: 1.5 }) 
                      .to(man.position, { x: 3, y: 0, duration: 1 }) 
                      .to(camera.position, {x: 2, y: 8, z: 25, duration: 2, ease: "power2.inOut"}, "-=2"); // 鏡頭跟隨
                    
                    // 神與人相聚互動
                    tl.to(man.rotation, { y: Math.PI/2 + 0.5, duration: 0.5 })
                      .to(god.position, { x: 5, duration: 1 }, "-=0.5");
                    break;
            }
        }

        // ==========================================
        // 8. UI 更新與事件綁定
        // ==========================================
        const uiTitle = document.getElementById('story-title');
        const uiContent = document.getElementById('story-content');
        const btnPrev = document.getElementById('btn-prev');
        const btnNext = document.getElementById('btn-next');
        const stageCounter = document.getElementById('stage-counter');
        const indicatorsContainer = document.getElementById('stage-indicators');

        // 動態生成底部 5 個階段圓點
        for(let i=0; i<5; i++) {
            const dot = document.createElement('div');
            dot.className = `w-8 md:w-12 h-2 rounded-full transition-all cursor-pointer ${i === 0 ? 'bg-yellow-400 shadow-[0_0_8px_rgba(250,204,21,0.8)]' : 'bg-white/20 hover:bg-white/40'}`;
            dot.onclick = () => updateStage(i);
            indicatorsContainer.appendChild(dot);
        }

        // 更新介面文字與按鈕狀態
        function updateUI() {
            // 文字淡入淡出效果
            uiTitle.style.opacity = 0;
            uiContent.style.opacity = 0;
            
            setTimeout(() => {
                uiTitle.innerHTML = storyData[currentStage].title;
                uiContent.innerHTML = storyData[currentStage].content;
                uiTitle.style.opacity = 1;
                uiContent.style.opacity = 1;
            }, 300);

            // 按鈕禁用邏輯與顏色變換
            btnPrev.disabled = currentStage === 0;
            btnNext.disabled = currentStage === 4;
            if (currentStage === 4) {
                btnNext.textContent = "已完成";
                btnNext.classList.remove('bg-yellow-500', 'hover:bg-yellow-400');
                btnNext.classList.add('bg-green-500', 'hover:bg-green-400');
            } else {
                btnNext.textContent = "下一頁";
                btnNext.classList.add('bg-yellow-500', 'hover:bg-yellow-400');
                btnNext.classList.remove('bg-green-500', 'hover:bg-green-400');
            }

            stageCounter.textContent = `${currentStage + 1} / 5`;

            // 更新圓點進度狀態
            const dots = indicatorsContainer.children;
            for(let i=0; i<dots.length; i++) {
                if (i === currentStage) {
                    dots[i].className = 'w-10 md:w-14 h-2 rounded-full transition-all cursor-pointer bg-yellow-400 shadow-[0_0_8px_rgba(250,204,21,0.8)]';
                } else if (i < currentStage) {
                    dots[i].className = 'w-8 md:w-12 h-2 rounded-full transition-all cursor-pointer bg-yellow-400/50';
                } else {
                    dots[i].className = 'w-8 md:w-12 h-2 rounded-full transition-all cursor-pointer bg-white/20 hover:bg-white/40';
                }
            }
        }

        // 統一切換階段的入口函數
        function updateStage(newStage) {
            if (newStage < 0 || newStage > 4) return;
            currentStage = newStage;
            updateUI();
            playStageAnimation(currentStage);
        }

        // 綁定按鈕事件
        btnPrev.addEventListener('click', () => updateStage(currentStage - 1));
        btnNext.addEventListener('click', () => updateStage(currentStage + 1));
        document.getElementById('btn-reset').addEventListener('click', () => updateStage(0));

        // 大字版切換邏輯
        document.getElementById('btn-text-size').addEventListener('click', () => {
            isLargeText = !isLargeText;
            const btn = document.getElementById('btn-text-size');
            if (isLargeText) {
                uiTitle.classList.replace('text-xl', 'text-3xl');
                uiTitle.classList.replace('md:text-2xl', 'md:text-4xl');
                uiContent.classList.replace('text-base', 'text-2xl');
                uiContent.classList.replace('md:text-lg', 'md:text-3xl');
                btn.classList.add('bg-white/40', 'text-yellow-300');
            } else {
                uiTitle.classList.replace('text-3xl', 'text-xl');
                uiTitle.classList.replace('md:text-4xl', 'md:text-2xl');
                uiContent.classList.replace('text-2xl', 'text-base');
                uiContent.classList.replace('md:text-3xl', 'md:text-lg');
                btn.classList.remove('bg-white/40', 'text-yellow-300');
            }
        });

        // 處理視窗大小改變 (RWD自適應)
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ==========================================
        // 9. 主渲染迴圈 (RequestAnimationFrame)
        // ==========================================
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // 神與耶穌的光暈呼吸特效
            if (god.children[2]) god.children[2].scale.setScalar(1 + Math.sin(time * 2) * 0.1);
            if (jesus.visible && jesus.children[2]) jesus.children[2].scale.setScalar(1 + Math.sin(time * 2.5) * 0.1);

            // 白雲緩慢飄動
            cloudsGroup.children.forEach(cloud => {
                cloud.position.x += 0.01;
                // 飄到盡頭後從另一端重新出現
                if(cloud.position.x > 40) cloud.position.x = -40;
            });

            // 雨水下落動畫
            if (rainSystem.visible) {
                const positions = rainSystem.geometry.attributes.position.array;
                for(let i=1; i<positions.length; i+=3) {
                    positions[i] -= 0.5; // 下落速度
                    if(positions[i] < -5) positions[i] = 20; // 回到頂部
                }
                rainSystem.geometry.attributes.position.needsUpdate = true;
            }

            // 河流流動特效 (透過透明度微調產生水波錯覺)
            river.material.opacity = 0.8 + Math.sin(time) * 0.1;

            controls.update(); // 必須呼叫，OrbitControls 才有阻尼滑順效果
            renderer.render(scene, camera);
        }

        // ==========================================
        // 10. 啟動程式
        // ==========================================
        updateUI();
        resetPositions();
        animate();

    </script>
</body>
</html>
